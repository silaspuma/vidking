<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vidking Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #050810;
      --bg-alt: #0c1020;
      --card-bg: #111827;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.25);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --radius-lg: 1rem;
      --radius-sm: 0.5rem;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827, #020617 55%);
      color: var(--text);
    }

    body.theater {
      background: #000;
      overflow-x: hidden;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.25rem 1rem 2.5rem;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      margin-bottom: 1rem;
    }

    @media (min-width: 700px) {
      header {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
    }

    .title-block h1 {
      margin: 0 0 0.2rem;
      font-size: 1.8rem;
      letter-spacing: 0.05em;
    }

    .title-block p {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .nav {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.25rem;
    }

    .nav-btn {
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--muted);
      font-size: 0.85rem;
      cursor: pointer;
    }

    .nav-btn.active {
      border-color: var(--accent);
      color: #dbeafe;
      background: rgba(37,99,235,0.3);
    }

    .controls {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .search-input {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.45rem 0.7rem;
      border-radius: 999px;
      font-size: 0.9rem;
      min-width: 190px;
      outline: none;
    }

    .search-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .select-input {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.45rem 0.7rem;
      border-radius: 999px;
      font-size: 0.9rem;
      min-width: 150px;
      outline: none;
    }

    .section { display: none; }
    .section.active { display: block; }

    .section-title-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.5rem;
      margin-top: 0.75rem;
    }

    .section-title-row h2 {
      margin: 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .section-title-row span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .card-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .item-card {
      width: 150px;
      border-radius: 0.9rem;
      background: linear-gradient(145deg, var(--card-bg), #020617);
      border: 1px solid var(--border);
      padding: 0.4rem;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      box-shadow: 0 12px 30px rgba(0,0,0,0.4);
    }

    .card-actions {
      display: flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      margin-top: 0.25rem;
    }

    .card-actions .btn {
      flex: 1 1 100%;
      text-align: center;
      padding: 0.35rem 0.5rem;
    }

    .card-actions .btn.subtle {
      color: #cbd5e1;
      border-color: rgba(148,163,184,0.35);
    }

    .item-card:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .item-poster {
      width: 100%;
      border-radius: 0.7rem;
      overflow: hidden;
      background: #020617;
      aspect-ratio: 2 / 3;
    }

    .item-poster img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .item-title {
      font-size: 0.85rem;
      font-weight: 500;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .item-meta {
      font-size: 0.75rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 0.35rem;
    }

    .pill-small {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.1rem 0.45rem;
      font-size: 0.7rem;
      color: var(--muted);
      background: rgba(15,23,42,0.8);
    }

    /* PLAYER PAGE */

    #playerSectionWrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: radial-gradient(circle at top, #020617, #000);
      padding: 1rem;
      border-radius: 1.1rem;
      border: 1px solid var(--border);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
      width: 100%;
    }

    #playerTopRow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    #playerTopRow h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .player-actions {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--muted);
      padding: 0.35rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .btn.primary {
      border-color: var(--accent);
      color: #dbeafe;
      background: rgba(37,99,235,0.25);
    }

    /* Same player layout for normal + theater (16:9 box) */
    .player-wrapper {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    /* 16:9 aspect-ratio box */
    .player-aspect {
      position: relative;
      width: 100%;
      padding-bottom: 56.25%; /* 16:9 */
      background: #000;
    }

    .player-aspect iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    #playerBottomRow {
      margin-top: 0.75rem;
      width: 100%;
      max-width: 1200px;
      padding: 0 1rem;
    }

    #descriptionPanel {
      background: linear-gradient(145deg, var(--card-bg), #020617);
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      padding: 0.75rem;
    }

    #descriptionPanel h3 {
      margin: 0 0 0.4rem;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    #descriptionText {
      font-size: 0.85rem;
      color: var(--muted);
    }

    #descMeta {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 0.4rem;
    }

    /* TMDb search panel */

    .tmdb-panel {
      margin-top: 1.25rem;
      padding: 1rem;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top left, #111827, #020617);
    }

    .tmdb-header {
      margin: 0 0 0.5rem;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .tmdb-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .tmdb-input {
      flex: 1 1 220px;
      background: #0b1020;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 0.5rem 0.75rem;
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
    }

    .tmdb-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .tmdb-button {
      border-radius: 999px;
      padding: 0.5rem 0.9rem;
      border: 1px solid #2563eb;
      background: rgba(37, 99, 235, 0.22);
      color: #dbeafe;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .tmdb-status {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }

    .tmdb-results {
      max-height: 260px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .tmdb-result-row {
      display: flex;
      gap: 0.5rem;
      padding: 0.4rem 0.55rem;
      border-radius: 0.6rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
    }

    .tmdb-poster-wrap {
      flex: 0 0 40px;
      height: 60px;
      border-radius: 0.4rem;
      overflow: hidden;
      background: #020617;
    }

    .tmdb-poster-wrap img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .tmdb-body {
      flex: 1;
      min-width: 0;
    }

    .tmdb-title {
      font-size: 0.9rem;
      font-weight: 500;
      margin-bottom: 0.2rem;
    }

    .tmdb-meta {
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    .tmdb-overview {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .tmdb-actions {
      margin-top: 0.3rem;
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    
    /* === THEATER MODE FIXES === */
    /* Make theater mode full-width but keep 16:9 inside the viewport */
    body.theater .page {
      max-width: none;
      width: 100vw;
      margin: 0;
      padding: 0;
    }

    /* Flatten the player card in theater and center it */
    body.theater #playerSectionWrapper {
      border-radius: 0;
      border: none;
      box-shadow: none;
      padding: 1rem 0 1.5rem 0;
      align-items: center;
    }

    /* Let the player grow, but cap its width so 16:9 height fits on screen */
    body.theater .player-wrapper {
      width: min(100vw, calc((100vh - 6rem) * 16 / 9));
      max-width: 100vw;
      margin: 0 auto;
      padding: 0;
    }

    /* Keep the same 16:9 aspect box */
    body.theater .player-aspect {
      padding-bottom: 56.25%;
    }

    /* Ensure details panel doesn't stretch wider than player */
    body.theater #playerBottomRow {
      max-width: 100%;
      padding: 0;
    }
footer {
      margin-top: 1.4rem;
      font-size: 0.75rem;
      color: var(--muted);
      text-align: center;
    }

    body.theater header,
    body.theater .tmdb-panel,
    body.theater footer,
    body.theater #homeSection,
    body.theater #librarySection {
      display: none !important;
    }

    body.theater #playerSection {
      padding: 0;
    }

    /* DEVICE ADAPTIVE STYLES */
    body.mobile .page {
      max-width: none;
      padding: 0.75rem 0.65rem 1.6rem;
    }

    body.mobile header {
      gap: 0.4rem;
    }

    body.mobile .controls {
      width: 100%;
      justify-content: space-between;
      gap: 0.4rem;
    }

    body.mobile .search-input,
    body.mobile .select-input {
      flex: 1 1 0;
      min-width: 0;
      font-size: 0.95rem;
      padding: 0.55rem 0.7rem;
    }

    body.mobile .nav-btn,
    body.mobile .btn {
      padding: 0.55rem 0.85rem;
      font-size: 0.95rem;
    }

    body.mobile .item-card {
      width: clamp(150px, 44vw, 220px);
    }

    body.mobile .card-row {
      justify-content: center;
    }

    body.tv .page {
      max-width: 1400px;
      padding: 1.1rem 1rem 2rem;
    }

    body.tv .nav-btn,
    body.tv .btn {
      padding: 0.6rem 1rem;
      font-size: 1rem;
      letter-spacing: 0.02em;
    }

    body.tv .title-block h1 {
      font-size: 2rem;
    }

    body.tv .controls {
      gap: 0.8rem;
    }

    body.tv .search-input,
    body.tv .select-input {
      font-size: 1rem;
      padding: 0.6rem 0.85rem;
    }

    body.tv .card-row {
      justify-content: center;
      gap: 1rem;
    }

    body.tv .item-card {
      width: 180px;
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="title-block">
        <h1>Vidking Hub</h1>
        <p>Home, library & player for our Vidking setup.</p>
        <div class="nav">
          <button class="nav-btn active" data-route="home">Home</button>
          <button class="nav-btn" data-route="search">Search</button>
          <button class="nav-btn" data-route="library">Library</button>
        </div>
      </div>
      <div class="controls">
        <input
          id="searchInput"
          class="search-input"
          type="search"
          placeholder="Search my library…"
        />
        <select id="filterSelect" class="select-input">
          <option value="all">All types</option>
          <option value="movie">Movies</option>
          <option value="tv">Shows</option>
          <option value="watchlist">Watchlist</option>
        </select>
      </div>
    </header>

    <!-- SEARCH SECTION -->
    <section id="searchSection" class="section">
      <section class="tmdb-panel">
        <h2 class="tmdb-header">Search Results</h2>
        <div class="tmdb-row">
          <input
            id="tmdbSearchInput"
            class="tmdb-input"
            type="search"
            placeholder="Search TMDb (movie / show)…"
          />
          <button id="tmdbSearchButton" class="tmdb-button" type="button">
            Search
          </button>
        </div>
        <div id="tmdbStatus" class="tmdb-status">
          Type a title above and click Search.
        </div>
        <div id="tmdbResults" class="tmdb-results"></div>
      </section>
    </section>

    <!-- HOME SECTION -->
    <section id="homeSection" class="section active">
      <div class="section-title-row">
        <h2>Continue Watching</h2>
        <span id="continueCount"></span>
      </div>
      <div id="continueRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>My Watchlist</h2>
        <span id="watchlistCount"></span>
      </div>
      <div id="watchlistRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>Popular Movies (region)</h2>
        <span id="popularMoviesLabel"></span>
      </div>
      <div id="popularMoviesRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>Popular Shows (region)</h2>
        <span id="popularTvLabel"></span>
      </div>
      <div id="popularTvRow" class="card-row"></div>
    </section>

    <!-- LIBRARY SECTION -->
    <section id="librarySection" class="section">
      <div class="section-title-row">
        <h2>My Watchlist (library)</h2>
        <span id="libraryWatchlistCount"></span>
      </div>
      <div id="libraryWatchlistRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>My Library</h2>
        <span id="libraryCount"></span>
      </div>
      <div id="libraryRow" class="card-row"></div>
    </section>

    <!-- PLAYER SECTION -->
    <section id="playerSection" class="section">
      <div id="playerSectionWrapper">
        <div id="playerTopRow">
          <h2 id="playerTitle">Nothing playing</h2>
          <div class="player-actions">
            <button id="backHomeBtn" class="btn">← Back</button>
            <button id="watchlistToggleBtn" class="btn">Add to watchlist</button>
            <button id="castBtn" class="btn">Cast</button>
            <button id="theaterBtn" class="btn primary">Theater mode</button>
          </div>
        </div>

        <div class="player-wrapper" id="playerContainer">
          <div class="player-aspect">
            <iframe
              id="vidkingPlayerFrame"
              src=""
              width="100%"
              height="100%"
              frameborder="0"
              allow="autoplay; fullscreen; encrypted-media"
              allowfullscreen
              loading="lazy"
            ></iframe>
          </div>
        </div>

        <div id="playerBottomRow">
          <div id="descriptionPanel">
            <h3>Details</h3>
            <div id="descriptionText">Pick something from Home or Library to play.</div>
            <div id="descMeta"></div>
          </div>
        </div>
      </div>
    </section>

    <footer>
      Data is stored locally in this browser using localStorage.
    </footer>
  </div>

  <script>
    /******************************************************************
     * CONFIG
     ******************************************************************/
    const TMDB_API_KEY = "d89facea7c73a78ab167ef244381a9ee"; // your key
    const TMDB_API_BASE = "https://api.themoviedb.org/3";
    const TMDB_IMG_BASE = "https://image.tmdb.org/t/p/w300";
    const TMDB_THUMB_BASE = "https://image.tmdb.org/t/p/w92";
    const REGION = "US";
    const STORAGE_KEY = "vidkingHubLibraryV1";
    const CAST_SDK_URL =
      "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";

    let library = [];
    let popularMovies = [];
    let popularTv = [];
    let currentItem = null;
    let currentSeason = 1;
    let currentEpisode = 1;
    let currentRoute = "home";
    let playerSrcWatcher = null;
    let lastPlayerSrc = "";
    let useEmbedAutonext = false;
    let isCasting = false;
    let castContext = null;
    let castSession = null;
    let castMedia = null;
    let castInitPromise = null;

    /******************************************************************
     * STORAGE HELPERS
     ******************************************************************/
    function saveLibrary() {
      try {
        const data = JSON.stringify(library);
        localStorage.setItem(STORAGE_KEY, data);
      } catch (e) {
        console.warn("Could not save library:", e);
      }
    }

    function loadLibraryFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          library = parsed;
        }
      } catch (e) {
        console.warn("Could not load library:", e);
      }
    }

    /******************************************************************
     * DOM
     ******************************************************************/
    const routeButtons = document.querySelectorAll(".nav-btn");
    const homeSection = document.getElementById("homeSection");
    const searchSection = document.getElementById("searchSection");
    const librarySection = document.getElementById("librarySection");
    const playerSection = document.getElementById("playerSection");

    const continueRow = document.getElementById("continueRow");
    const watchlistRow = document.getElementById("watchlistRow");
    const continueCount = document.getElementById("continueCount");
    const watchlistCount = document.getElementById("watchlistCount");
    const popularMoviesRow = document.getElementById("popularMoviesRow");
    const popularTvRow = document.getElementById("popularTvRow");
    const popularMoviesLabel = document.getElementById("popularMoviesLabel");
    const popularTvLabel = document.getElementById("popularTvLabel");

    const libraryRow = document.getElementById("libraryRow");
    const libraryCount = document.getElementById("libraryCount");
    const libraryWatchlistRow = document.getElementById("libraryWatchlistRow");
    const libraryWatchlistCount = document.getElementById("libraryWatchlistCount");

    const searchInput = document.getElementById("searchInput");
    const filterSelect = document.getElementById("filterSelect");

    const tmdbSearchInput = document.getElementById("tmdbSearchInput");
    const tmdbSearchButton = document.getElementById("tmdbSearchButton");
    const tmdbStatusEl = document.getElementById("tmdbStatus");
    const tmdbResultsEl = document.getElementById("tmdbResults");

    const playerTitle = document.getElementById("playerTitle");
    const playerContainer = document.getElementById("playerContainer");
    const descriptionText = document.getElementById("descriptionText");
    const descMeta = document.getElementById("descMeta");
    const backHomeBtn = document.getElementById("backHomeBtn");
    const watchlistToggleBtn = document.getElementById("watchlistToggleBtn");
    const castBtn = document.getElementById("castBtn");
    const theaterBtn = document.getElementById("theaterBtn");

    /******************************************************************
     * ROUTING
     ******************************************************************/
    function setRoute(route) {
      const leavingPlayer = currentRoute === "player" && route !== "player";
      const hidingPlayer = route !== "player";

      if (leavingPlayer || hidingPlayer) {
        // clear iframe so Vidking stops audio whenever player is hidden
        stopPlayerWatcher();
        const iframe = document.getElementById("vidkingPlayerFrame");
        if (iframe) iframe.src = "";
        lastPlayerSrc = "";
        document.body.classList.remove("theater");
        theaterBtn.textContent = "Theater mode";
      }

      currentRoute = route;

      homeSection.classList.remove("active");
      searchSection.classList.remove("active");
      librarySection.classList.remove("active");
      playerSection.classList.remove("active");

      routeButtons.forEach((b) =>
        b.classList.toggle("active", b.dataset.route === route)
      );

      if (route === "home") homeSection.classList.add("active");
      if (route === "search") searchSection.classList.add("active");
      if (route === "library") librarySection.classList.add("active");
      if (route === "player") playerSection.classList.add("active");
    }

    routeButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        setRoute(btn.dataset.route);
        if (btn.dataset.route === "library") {
          renderLibrary();
        } else if (btn.dataset.route === "search") {
          tmdbSearchInput?.focus();
        }
      });
    });

    /******************************************************************
     * LIBRARY / STATE HELPERS
     ******************************************************************/
    function findInLibraryByTmdb(type, tmdbId) {
      return library.find((x) => x.type === type && String(x.tmdbId) === String(tmdbId));
    }

    function addToLibraryFromTmdbResult(result, isMovie, { makeWatchlist = false } = {}) {
      const tmdbId = result.id;
      const existing = findInLibraryByTmdb(isMovie ? "movie" : "tv", tmdbId);
      if (existing) {
        if (makeWatchlist && !existing.isWatchlist) {
          existing.isWatchlist = true;
          saveLibrary();
          renderHome();
          renderLibrary();
        }
        return existing;
      }

      const title = isMovie ? result.title : result.name;
      const date = isMovie ? result.release_date : result.first_air_date;
      const year = date ? date.slice(0, 4) : "";
      const overview = result.overview || "";
      const poster = result.poster_path
        ? TMDB_IMG_BASE + result.poster_path
        : "";
      const backdrop = result.backdrop_path
        ? TMDB_IMG_BASE + result.backdrop_path
        : "";

      const item = {
        id: `${isMovie ? "movie" : "tv"}-${tmdbId}-${Date.now()}`,
        tmdbId,
        type: isMovie ? "movie" : "tv",
        title,
        year,
        overview,
        poster,
        backdrop,
        addedAt: Date.now(),
        lastWatchedAt: 0,
        isWatchlist: !!makeWatchlist,
        lastSeason: 1,
        lastEpisode: 0,
        lastProgress: 0,
        lastPosition: 0,
        lastDuration: 0
      };

      library.push(item);
      saveLibrary();
      renderLibrary();
      renderHome();
      return item;
    }

    function markWatched(item) {
      item.lastWatchedAt = Date.now();
      saveLibrary();
      renderHome();
    }

    function toggleWatchlist(item) {
      item.isWatchlist = !item.isWatchlist;
      saveLibrary();
      renderHome();
      renderLibrary();
      updateWatchlistButton();
    }

    function removeFromLibrary(item) {
      const idx = library.findIndex((x) => x.id === item.id);
      if (idx === -1) return;

      library.splice(idx, 1);
      if (currentItem && currentItem.id === item.id) {
        currentItem = null;
        playerContainer.innerHTML = "";
        renderPlayerDetails();
      }

      saveLibrary();
      renderHome();
      renderLibrary();
    }

    /******************************************************************
     * CARD RENDERING
     ******************************************************************/
    function makeCard(item, opts = {}) {
      const div = document.createElement("div");
      div.className = "item-card vk-card";
      div.dataset.vidkingId = item.tmdbId || item.id || "";
      div.dataset.vidkingType = item.type || "";
      div.dataset.vidkingTitle = item.title || "";
      div.dataset.vidkingBackdrop = item.backdrop || item.backdropPath || "";
      div.dataset.vidkingPoster = item.poster || item.posterPath || "";
      div.dataset.vidkingOverview = item.overview || "";
      div.dataset.vidkingYear = item.year || "";

      const posterWrap = document.createElement("div");
      posterWrap.className = "item-poster";
      if (item.poster) {
        const img = document.createElement("img");
        img.src = item.poster;
        img.alt = item.title;
        posterWrap.appendChild(img);
      }
      div.appendChild(posterWrap);

      const titleEl = document.createElement("div");
      titleEl.className = "item-title";
      titleEl.textContent = item.title;
      div.appendChild(titleEl);

      const metaEl = document.createElement("div");
      metaEl.className = "item-meta";
      const left = document.createElement("span");
      left.textContent =
        (item.type === "movie" ? "Movie" : "Show") +
        (item.year ? " • " + item.year : "");
      const right = document.createElement("span");
      right.textContent = opts.rightLabel || "";
      metaEl.appendChild(left);
      metaEl.appendChild(right);
      div.appendChild(metaEl);

      if (opts.showWatchlistPill && item.isWatchlist) {
        const pill = document.createElement("div");
        pill.className = "pill-small";
        pill.textContent = "Watchlist";
        div.appendChild(pill);
      }

      if (opts.showActions) {
        const actionsWrap = document.createElement("div");
        actionsWrap.className = "card-actions";

        const wlBtn = document.createElement("button");
        wlBtn.className = "btn subtle";
        wlBtn.type = "button";
        const setWatchlistLabel = () => {
          wlBtn.textContent = item.isWatchlist
            ? "Remove from watchlist"
            : "Add to watchlist";
        };
        setWatchlistLabel();
        wlBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleWatchlist(item);
          setWatchlistLabel();
        });
        actionsWrap.appendChild(wlBtn);

        if (opts.onRemove) {
          const removeBtn = document.createElement("button");
          removeBtn.className = "btn";
          removeBtn.type = "button";
          removeBtn.textContent = "Remove from library";
          removeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            opts.onRemove(item);
          });
          actionsWrap.appendChild(removeBtn);
        }

        div.appendChild(actionsWrap);
      }

      return div;
    }

    /******************************************************************
     * HOME RENDERING
     ******************************************************************/
    function renderHome() {
      const cont = [...library]
        .filter((x) => x.lastWatchedAt)
        .sort((a, b) => b.lastWatchedAt - a.lastWatchedAt)
        .slice(0, 12);

      continueRow.innerHTML = "";
      continueCount.textContent = cont.length ? `${cont.length} items` : "None";
      cont.forEach((item) => {
        const label =
          item.type === "tv" && item.lastSeason && item.lastEpisode
            ? `S${String(item.lastSeason).padStart(2, "0")}E${String(
                item.lastEpisode
              ).padStart(2, "0")}`
            : "Continue";
        const card = makeCard(item, {
          rightLabel: label,
          showWatchlistPill: true,
          fromRoute: "home"
        });
        continueRow.appendChild(card);
      });

      const wl = library.filter((x) => x.isWatchlist);
      watchlistRow.innerHTML = "";
      watchlistCount.textContent = wl.length ? `${wl.length} items` : "None";
      wl.slice(0, 12).forEach((item) => {
        const card = makeCard(item, {
          rightLabel: "Watchlist",
          showWatchlistPill: true,
          fromRoute: "home"
        });
        watchlistRow.appendChild(card);
      });

      popularMoviesRow.innerHTML = "";
      popularMoviesLabel.textContent = popularMovies.length
        ? `${popularMovies.length} from TMDb`
        : "";
      popularMovies.slice(0, 12).forEach((r) => {
        const temp = {
          type: "movie",
          tmdbId: r.id,
          title: r.title,
          year: (r.release_date || "").slice(0, 4),
          overview: r.overview || "",
          poster: r.poster_path ? TMDB_IMG_BASE + r.poster_path : "",
          backdrop: r.backdrop_path ? TMDB_IMG_BASE + r.backdrop_path : ""
        };
        const card = makeCard(temp, {
          rightLabel: "Popular",
          fromRoute: "home"
        });
        popularMoviesRow.appendChild(card);
      });

      popularTvRow.innerHTML = "";
      popularTvLabel.textContent = popularTv.length
        ? `${popularTv.length} from TMDb`
        : "";
      popularTv.slice(0, 12).forEach((r) => {
        const temp = {
          type: "tv",
          tmdbId: r.id,
          title: r.name,
          year: (r.first_air_date || "").slice(0, 4),
          overview: r.overview || "",
          poster: r.poster_path ? TMDB_IMG_BASE + r.poster_path : "",
          backdrop: r.backdrop_path ? TMDB_IMG_BASE + r.backdrop_path : ""
        };
        const card = makeCard(temp, {
          rightLabel: "Popular",
          fromRoute: "home"
        });
        popularTvRow.appendChild(card);
      });
    }

    /******************************************************************
     * LIBRARY RENDERING
     ******************************************************************/
    function renderLibrary() {
      const term = searchInput.value.trim().toLowerCase();
      const filter = filterSelect.value;

      let watchlistItems = library.filter((x) => x.isWatchlist);
      if (filter === "movie") watchlistItems = watchlistItems.filter((x) => x.type === "movie");
      if (filter === "tv") watchlistItems = watchlistItems.filter((x) => x.type === "tv");

      if (term) {
        watchlistItems = watchlistItems.filter((x) =>
          (x.title + " " + x.overview).toLowerCase().includes(term)
        );
      }
      libraryWatchlistRow.innerHTML = "";
      libraryWatchlistCount.textContent = watchlistItems.length
        ? `${watchlistItems.length} items`
        : "None";

      watchlistItems
        .sort((a, b) => b.addedAt - a.addedAt)
        .forEach((item) => {
          const card = makeCard(item, {
            rightLabel: "Watchlist",
            showWatchlistPill: true,
            fromRoute: "library",
            showActions: true,
            onRemove: removeFromLibrary
          });
          libraryWatchlistRow.appendChild(card);
        });

      let list = [...library];

      if (filter === "movie") list = list.filter((x) => x.type === "movie");
      if (filter === "tv") list = list.filter((x) => x.type === "tv");
      if (filter === "watchlist") list = list.filter((x) => x.isWatchlist);

      if (term) {
        list = list.filter((x) =>
          (x.title + " " + x.overview).toLowerCase().includes(term)
        );
      }

      libraryRow.innerHTML = "";
      libraryCount.textContent = list.length
        ? `${list.length} items`
        : "Empty";

      list
        .sort((a, b) => b.addedAt - a.addedAt)
        .forEach((item) => {
          const label =
            item.type === "tv" && item.lastSeason && item.lastEpisode
              ? `S${String(item.lastSeason).padStart(2, "0")}E${String(
                  item.lastEpisode
                ).padStart(2, "0")}`
              : item.isWatchlist
              ? "Watchlist"
              : "";
          const card = makeCard(item, {
            rightLabel: label,
            showWatchlistPill: true,
            fromRoute: "library",
            showActions: true,
            onRemove: removeFromLibrary
          });
          libraryRow.appendChild(card);
        });
    }

    // search / filter always work on Library and show that tab
    searchInput.addEventListener("input", () => {
      if (currentRoute !== "library") {
        setRoute("library");
      }
      renderLibrary();
    });
    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const query = searchInput.value;
        if (tmdbSearchInput) tmdbSearchInput.value = query;
        setRoute("search");
        tmdbSearchInput?.focus();
        searchTmdb(query);
      }
    });
    filterSelect.addEventListener("change", () => {
      if (currentRoute !== "library") {
        setRoute("library");
      }
      renderLibrary();
    });

    /******************************************************************
     * PLAYER
     ******************************************************************/
    function buildVidkingEmbedUrl(item, progressSeconds) {
      // item.type: "movie" | "tv"
      // item.id: TMDB id (string or number)
      // item.season, item.episode: for TV shows (fallback to 1)
      const base = "https://www.vidking.net";
      const tmdbId = item.id || item.tmdbId;
      if (!tmdbId) return "";
      let path;

      if (item.type === "tv") {
        const season = item.season || item.lastSeason || 1;
        const episode = item.episode || item.lastEpisode || 1;
        path = `/embed/tv/${tmdbId}/${season}/${episode}`;
      } else {
        path = `/embed/movie/${tmdbId}`;
      }

      const params = new URLSearchParams({
        autoPlay: "true",
        nextEpisode: "true",
        episodeSelector: "true"
      });

      // you can still add extra params like color if needed in the future


      if (progressSeconds && progressSeconds > 0) {
        params.set("progress", Math.floor(progressSeconds).toString());
      }

      return `${base}${path}?${params.toString()}`;
    }

    function loadVidkingStream(item) {
      const iframe = document.getElementById("vidkingPlayerFrame");
      if (!iframe) return;

      const embedItem = {
        ...item,
        id: item.tmdbId || item.id,
        season: item.season || item.lastSeason || currentSeason || 1,
        episode: item.episode || item.lastEpisode || currentEpisode || 1
      };

      // Load saved progress for this item if available
      let resumeSeconds = 0;
      try {
        const key = `vk.progress.${embedItem.type}.${embedItem.id}`;
        const saved = localStorage.getItem(key);
        if (saved) {
          const data = JSON.parse(saved);
          if (data && typeof data.currentTime === "number") {
            resumeSeconds = data.currentTime;
          }
        }
      } catch (e) {
        console.warn("Could not read saved Vidking progress", e);
      }

      iframe.src = buildVidkingEmbedUrl(embedItem, resumeSeconds);
    }

    function stopPlayerWatcher() {
      if (playerSrcWatcher) {
        clearInterval(playerSrcWatcher);
        playerSrcWatcher = null;
      }
    }

    function syncEpisodeFromSrc(src) {
      const match = src.match(/\/tv\/(\d+)\/(\d+)\/(\d+)/);
      if (!match || !currentItem) return;

      const [, tmdbId, seasonStr, epStr] = match;
      if (String(tmdbId) !== String(currentItem.tmdbId)) return;

      const parsedSeason = parseInt(seasonStr, 10);
      const parsedEpisode = parseInt(epStr, 10);
      if (Number.isFinite(parsedSeason)) currentSeason = parsedSeason;
      if (Number.isFinite(parsedEpisode)) currentEpisode = parsedEpisode;

      currentItem.lastSeason = currentSeason;
      currentItem.lastEpisode = currentEpisode;
      markWatched(currentItem);
      renderPlayerDetails();
    }

    function startPlayerWatcher() {
      stopPlayerWatcher();
      const iframe = playerContainer.querySelector("iframe");
      if (!iframe) return;
      lastPlayerSrc = iframe.getAttribute("src") || "";
      if (lastPlayerSrc) syncEpisodeFromSrc(lastPlayerSrc);

      playerSrcWatcher = setInterval(() => {
        const src = iframe.getAttribute("src") || "";
        if (src && src !== lastPlayerSrc) {
          lastPlayerSrc = src;
          syncEpisodeFromSrc(src);
        }
      }, 1500);
    }

    window.addEventListener("message", (event) => {
      let data = event.data;

      try {
        if (typeof data === "string") {
          data = JSON.parse(data);
        }
      } catch {
        return;
      }

      if (!data || data.type !== "PLAYER_EVENT" || !data.data) return;

      const payload = data.data;
      // Expected payload fields based on Vidking docs:
      // id, mediatype ("movie" | "tv"), currentTime, duration,
      // progress (0–1), season, episode, timestamp, etc.

      const key = `vk.progress.${payload.mediatype}.${payload.id}`;
      const toStore = {
        currentTime: payload.currentTime,
        progress: payload.progress,
        season: payload.season,
        episode: payload.episode,
        timestamp: payload.timestamp
      };

      try {
        localStorage.setItem(key, JSON.stringify(toStore));
      } catch (e) {
        console.warn("Could not save Vidking progress", e);
      }
    });

    /******************************************************************
     * CASTING
     ******************************************************************/
    function loadCastSdk() {
      if (castInitPromise) return castInitPromise;

      castInitPromise = new Promise((resolve, reject) => {
        if (window.cast && window.cast.framework) {
          resolve();
          return;
        }

        const script = document.createElement("script");
        script.src = CAST_SDK_URL;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = (err) => reject(err);
        document.head.appendChild(script);
      });

      return castInitPromise;
    }

    async function setupCasting() {
      if (!castBtn) return;
      castBtn.disabled = true;

      try {
        await loadCastSdk();
        if (!(window.cast && window.cast.framework)) {
          throw new Error("Cast SDK not available");
        }

        castContext = cast.framework.CastContext.getInstance();
        castContext.setOptions({
          receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
          autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
        });

        castBtn.disabled = false;
        castBtn.title = "Cast to a wireless device";
        castBtn.addEventListener("click", onCastButtonClick);

        castContext.addEventListener(
          cast.framework.CastContextEventType.SESSION_STATE_CHANGED,
          handleCastSessionState
        );
      } catch (e) {
        console.warn("Casting unavailable", e);
        castBtn.textContent = "Cast unavailable";
      }
    }

    async function onCastButtonClick() {
      if (!castContext) return;

      if (isCasting && castSession) {
        castSession.endSession(true);
        return;
      }

      try {
        await castContext.requestSession();
      } catch (e) {
        console.warn("Cast request failed", e);
      }
    }

    function handleCastSessionState(event) {
      if (!event || !castContext) return;
      const state = event.sessionState;

      if (
        state === cast.framework.SessionState.SESSION_STARTED ||
        state === cast.framework.SessionState.SESSION_RESUMED
      ) {
        castSession = castContext.getCurrentSession();
        isCasting = true;
        castBtn.textContent = "Casting…";
        castBtn.classList.add("primary");
        syncCastMediaToCurrent(true);
      } else if (
        state === cast.framework.SessionState.SESSION_ENDING ||
        state === cast.framework.SessionState.SESSION_ENDED ||
        state === cast.framework.SessionState.SESSION_START_FAILED ||
        state === cast.framework.SessionState.NO_SESSION
      ) {
        isCasting = false;
        castMedia = null;
        castSession = null;
        castBtn.textContent = "Cast";
        castBtn.classList.remove("primary");
      }
    }

    function onCastMediaUpdate(isAlive) {
      if (!isAlive || !castMedia) return;
    }

    function syncCastMediaToCurrent(forceAutonext = false) {
      if (!isCasting || !castSession || !currentItem) return;
      if (!(window.chrome && chrome.cast && chrome.cast.media)) return;

      const embedItem = {
        ...currentItem,
        id: currentItem.tmdbId || currentItem.id,
        season: currentSeason,
        episode: currentEpisode
      };

      const src = buildVidkingEmbedUrl(
        embedItem,
        currentItem.lastPosition || currentItem.lastProgress || 0
      );

      const mediaInfo = new chrome.cast.media.MediaInfo(src, "text/html");
      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
      mediaInfo.metadata.title = currentItem.title || "Vidking";
      if (currentItem.type === "tv") {
        mediaInfo.metadata.subtitle =
          "S" +
          String(currentSeason).padStart(2, "0") +
          "E" +
          String(currentEpisode).padStart(2, "0");
      } else if (currentItem.year) {
        mediaInfo.metadata.subtitle = String(currentItem.year);
      }
      mediaInfo.customData = {
        tmdbId: currentItem.tmdbId,
        type: currentItem.type,
        season: currentSeason,
        episode: currentEpisode
      };

      const request = new chrome.cast.media.LoadRequest(mediaInfo);
      request.autoplay = true;

      castSession
        .loadMedia(request)
        .then((media) => {
          castMedia = media;
          if (castMedia) {
            castMedia.addUpdateListener(onCastMediaUpdate);
          }
        })
        .catch((err) => console.warn("Cast load failed", err));
    }

    function pushCastIfActive(forceAutonext = false) {
      if (!isCasting || !castSession) return;
      syncCastMediaToCurrent(forceAutonext);
    }

    function detectDevice() {
      const ua = navigator.userAgent || "";
      const isAndroidTv = /Android TV|BRAVIA|SMART-TV|HbbTV|NETTV/i.test(ua);
      const isBrowseHere = /BrowseHere/i.test(ua);
      const isMobile = !isAndroidTv && /Mobi|Android|iPhone|iPad|iPod/i.test(ua);

      if (isAndroidTv) {
        document.body.classList.add("tv");
      }

      if (isAndroidTv || isBrowseHere) {
        useEmbedAutonext = true;
      }

      if (isMobile) {
        document.body.classList.add("mobile");
      }
    }

    function updateWatchlistButton() {
      if (!currentItem) return;
      watchlistToggleBtn.textContent = currentItem.isWatchlist
        ? "Remove from watchlist"
        : "Add to watchlist";
    }

    function renderPlayerDetails() {
      if (!currentItem) {
        playerTitle.textContent = "Nothing playing";
        descriptionText.textContent =
          "Pick something from Home or Library to play.";
        descMeta.textContent = "";
        return;
      }

      playerTitle.textContent = currentItem.title;
      descriptionText.textContent = currentItem.overview || "No description.";
      descMeta.textContent =
        (currentItem.type === "movie" ? "Movie" : "Show") +
        (currentItem.year ? " • " + currentItem.year : "") +
        (currentItem.type === "tv"
          ? ` • Season ${currentSeason}, Episode ${currentEpisode}`
          : "");

      updateWatchlistButton();
    }

    function openVidkingPlayer(item) {
      const homeView = document.getElementById("homeSection");
      const searchView = document.getElementById("searchSection");
      const libraryView = document.getElementById("librarySection");
      const playerView = document.getElementById("playerSection");

      [homeView, searchView, libraryView].forEach((view) => {
        if (view) view.classList.remove("active");
      });
      if (playerView) playerView.classList.add("active");

      const tmdbId = item.tmdbId || item.id || "";
      const existing = tmdbId ? findInLibraryByTmdb(item.type, tmdbId) : null;
      const normalizedItem = existing || {
        id: item.id || `${item.type || "item"}-${tmdbId || Date.now()}`,
        tmdbId: tmdbId,
        type: item.type,
        title: item.title || "Unknown title",
        overview: item.overview || "",
        year: item.year || "",
        poster: item.posterPath || item.poster || "",
        backdrop: item.backdropPath || item.backdrop || "",
        lastSeason: item.lastSeason || 1,
        lastEpisode: item.lastEpisode || 0,
        lastProgress: item.lastProgress || 0,
        lastPosition: item.lastPosition || 0,
        lastDuration: item.lastDuration || 0
      };

      try {
        localStorage.setItem(
          "vk.currentItem",
          JSON.stringify({
            id: normalizedItem.tmdbId || normalizedItem.id,
            type: normalizedItem.type,
            title: normalizedItem.title,
            backdropPath: normalizedItem.backdrop || "",
            posterPath: normalizedItem.poster || "",
            overview: normalizedItem.overview || "",
            year: normalizedItem.year || ""
          })
        );
      } catch (e) {
        console.warn("Unable to store current Vidking item in localStorage", e);
      }

      if (typeof openPlayer === "function") {
        openPlayer(normalizedItem, { fromRoute: currentRoute || "home" });
        return;
      }

      if (typeof loadVidkingStream === "function") {
        loadVidkingStream(normalizedItem);
      }
    }

    function openPlayer(item, { fromRoute }) {
      currentItem = item;

      if (item.type === "tv") {
        currentSeason = item.lastSeason || 1;
        currentEpisode = item.lastEpisode || 1;
        if (currentEpisode < 1) currentEpisode = 1;
      } else {
        currentSeason = 1;
        currentEpisode = 1;
      }

      const embedItem = {
        ...item,
        id: item.tmdbId || item.id,
        season: currentSeason,
        episode: currentEpisode
      };

      stopPlayerWatcher();
      const iframe = document.getElementById("vidkingPlayerFrame");
      if (iframe) {
        iframe.src = "";
      }

      loadVidkingStream(embedItem);

      markWatched(item);
      renderPlayerDetails();
      startPlayerWatcher();
      pushCastIfActive(true);
      setRoute("player");
      window.scrollTo({ top: 0, behavior: "smooth" });

      backHomeBtn.dataset.backRoute = fromRoute || "home";
    }

    backHomeBtn.addEventListener("click", () => {
      document.body.classList.remove("theater");
      theaterBtn.textContent = "Theater mode";
      const route = backHomeBtn.dataset.backRoute || "home";
      setRoute(route);
    });

    watchlistToggleBtn.addEventListener("click", () => {
      if (!currentItem) return;
      toggleWatchlist(currentItem);
    });

    theaterBtn.addEventListener("click", () => {
      document.body.classList.toggle("theater");
      theaterBtn.textContent = document.body.classList.contains("theater")
        ? "Exit theater"
        : "Theater mode";
    });

    /******************************************************************
     * VIDKING WATCH PROGRESS EVENTS
     ******************************************************************/
    function handlePlayerMessage(event) {
      if (typeof event.data !== "string") return;

      let payload;
      try {
        payload = JSON.parse(event.data);
      } catch {
        return;
      }

      let info = null;

      // New format: { type: "PLAYER_EVENT", data: {...} }
      if (payload && payload.type === "PLAYER_EVENT" && payload.data) {
        info = payload.data;
      }
      // Older/simple format directly carrying id/mediaType/etc.
      else if (payload && payload.id && (payload.mediaType || payload.type)) {
        info = {
          id: payload.id,
          mediaType: payload.mediaType || payload.type,
          progress: payload.progress,
          currentTime: payload.currentTime ?? payload.timestamp,
          duration: payload.duration,
          season: payload.season,
          episode: payload.episode
        };
      }

      if (!info || !info.id || !(info.mediaType || info.mediatype)) return;

      const mediaType =
        (info.mediaType || info.mediatype) === "tv" ? "tv" : "movie";
      const tmdbId = String(info.id);
      const eventType = info.eventType || info.type || null;

      const item = library.find(
        (x) => x.type === mediaType && String(x.tmdbId) === tmdbId
      );
      if (!item) return;

      // Update watch progress
      item.lastWatchedAt = Date.now();
      if (typeof info.progress === "number") item.lastProgress = info.progress;
      if (typeof info.currentTime === "number")
        item.lastPosition = info.currentTime;
      if (typeof info.duration === "number")
        item.lastDuration = info.duration;

      if (mediaType === "tv") {
        if (info.season) item.lastSeason = info.season;
        if (info.episode) item.lastEpisode = info.episode;
      }

      saveLibrary();
      renderHome();
      renderLibrary();
    }

    window.addEventListener("message", handlePlayerMessage);

    /******************************************************************
     * TMDb SEARCH
     ******************************************************************/
    async function searchTmdb(query) {
      const q = query.trim();
      setRoute("search");

      if (!q) {
        tmdbStatusEl.textContent = "Type a title to search TMDb.";
        tmdbResultsEl.innerHTML = "";
        return;
      }

      if (!TMDB_API_KEY || TMDB_API_KEY === "REPLACE_WITH_YOUR_TMDB_KEY") {
        tmdbStatusEl.textContent =
          "TMDb API key missing. Edit index.html and set TMDB_API_KEY.";
        return;
      }

      window.scrollTo({ top: 0, behavior: "smooth" });
      tmdbStatusEl.textContent = "Searching TMDb…";
      tmdbResultsEl.innerHTML = "";

      try {
        const url =
          `${TMDB_API_BASE}/search/multi?api_key=${encodeURIComponent(
            TMDB_API_KEY
          )}&language=en-US&include_adult=false&query=${encodeURIComponent(q)}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        const results = (data.results || []).filter((r) =>
          ["movie", "tv"].includes(r.media_type)
        );
        if (!results.length) {
          tmdbStatusEl.textContent = "No results.";
          return;
        }
        tmdbStatusEl.textContent =
          "Found " +
          results.length +
          " result" +
          (results.length === 1 ? "" : "s") +
          ". Click to add.";
        renderTmdbResults(results.slice(0, 20));
      } catch (e) {
        console.error(e);
        tmdbStatusEl.textContent = "Error talking to TMDb.";
      }
    }

    function renderTmdbResults(results) {
      tmdbResultsEl.innerHTML = "";
      results.forEach((r) => {
        const isMovie = r.media_type === "movie";
        const row = document.createElement("div");
        row.className = "tmdb-result-row";

        const posterWrap = document.createElement("div");
        posterWrap.className = "tmdb-poster-wrap";
        if (r.poster_path) {
          const img = document.createElement("img");
          img.src = TMDB_THUMB_BASE + r.poster_path;
          img.alt = isMovie ? r.title : r.name;
          posterWrap.appendChild(img);
        }
        row.appendChild(posterWrap);

        const body = document.createElement("div");
        body.className = "tmdb-body";

        const titleEl = document.createElement("div");
        titleEl.className = "tmdb-title";
        const title = isMovie ? r.title : r.name;
        const date = isMovie ? r.release_date : r.first_air_date;
        const year = date ? date.slice(0, 4) : "";
        titleEl.textContent = title + (year ? " (" + year + ")" : "");
        body.appendChild(titleEl);

        const metaEl = document.createElement("div");
        metaEl.className = "tmdb-meta";
        metaEl.textContent =
          (isMovie ? "Movie" : "Show") + " • TMDb #" + r.id;
        body.appendChild(metaEl);

        const overviewEl = document.createElement("div");
        overviewEl.className = "tmdb-overview";
        const ov = r.overview || "";
        overviewEl.textContent =
          ov.length > 140 ? ov.slice(0, 137) + "…" : ov;
        body.appendChild(overviewEl);

        const actions = document.createElement("div");
        actions.className = "tmdb-actions";

        const addBtn = document.createElement("button");
        addBtn.className = "tmdb-button";
        addBtn.type = "button";
        addBtn.textContent = isMovie
          ? "Add movie to library"
          : "Add show to library";
        addBtn.addEventListener("click", () => {
          const item = addToLibraryFromTmdbResult(r, isMovie);
          openPlayer(item, { fromRoute: "search" });
        });

        actions.appendChild(addBtn);

        const watchlistBtn = document.createElement("button");
        watchlistBtn.className = "tmdb-button";
        watchlistBtn.type = "button";
        watchlistBtn.textContent = isMovie
          ? "Add movie to watchlist"
          : "Add show to watchlist";
        watchlistBtn.addEventListener("click", () => {
          const item = addToLibraryFromTmdbResult(r, isMovie, {
            makeWatchlist: true
          });
            if (!item.isWatchlist) {
              item.isWatchlist = true;
              saveLibrary();
            }
            renderHome();
            renderLibrary();
            openPlayer(item, { fromRoute: "search" });
          });

        actions.appendChild(watchlistBtn);
        body.appendChild(actions);

        row.appendChild(body);
        tmdbResultsEl.appendChild(row);
      });
    }

    tmdbSearchButton.addEventListener("click", () => {
      setRoute("search");
      tmdbSearchInput?.focus();
      searchTmdb(tmdbSearchInput.value);
    });
    tmdbSearchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        setRoute("search");
        searchTmdb(tmdbSearchInput.value);
      }
    });

    /******************************************************************
     * POPULAR FETCH
     ******************************************************************/
    async function loadPopular() {
      if (!TMDB_API_KEY || TMDB_API_KEY === "REPLACE_WITH_YOUR_TMDB_KEY") {
        renderHome();
        return;
      }

      try {
        const [movieRes, tvRes] = await Promise.all([
          fetch(
            `${TMDB_API_BASE}/movie/popular?api_key=${encodeURIComponent(
              TMDB_API_KEY
            )}&language=en-US&region=${encodeURIComponent(REGION)}`
          ),
          fetch(
            `${TMDB_API_BASE}/tv/popular?api_key=${encodeURIComponent(
              TMDB_API_KEY
            )}&language=en-US&region=${encodeURIComponent(REGION)}`
          )
        ]);

        if (movieRes.ok) {
          const m = await movieRes.json();
          popularMovies = m.results || [];
        }
        if (tvRes.ok) {
          const t = await tvRes.json();
          popularTv = t.results || [];
        }
      } catch (e) {
        console.error(e);
      } finally {
        renderHome();
      }
    }

    // Global delegated click handler for all Vidking cards
    document.addEventListener("click", (event) => {
      const card = event.target.closest(".vk-card[data-vidking-id]");
      if (!card) return;

      event.preventDefault();

      const item = {
        id: card.dataset.vidkingId,
        tmdbId: card.dataset.vidkingId,
        type: card.dataset.vidkingType,
        title: card.dataset.vidkingTitle || "",
        backdropPath: card.dataset.vidkingBackdrop || "",
        posterPath: card.dataset.vidkingPoster || "",
        overview: card.dataset.vidkingOverview || "",
        year: card.dataset.vidkingYear || ""
      };

      openVidkingPlayer(item);
    });

    /******************************************************************
     * INIT
     ******************************************************************/
    function init() {
      detectDevice();
      setupCasting();
      loadLibraryFromStorage();
      renderLibrary();
      renderHome();
      loadPopular();
    }

    init();
  </script>
</body>
</html>
